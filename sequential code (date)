#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <ctime>

// Task structure
struct Task {
    std::string name;
    std::tm deadline;  // Deadline as a date
    std::vector<std::string> dependencies;  // Task dependencies
    bool assigned = false;  // Task assignment status
};

// Member structure
struct Member {
    std::string name;
    bool isAvailable;  // Availability status of team members
};

// Function to calculate the number of days between two dates
int daysUntilDeadline(const std::tm& deadline) {
    std::time_t now = std::time(nullptr);  // Current time
    std::tm today = *std::localtime(&now);  // Convert time to date format

    // Calculate the difference in seconds between the deadline and today
    std::time_t deadline_time = std::mktime(const_cast<std::tm*>(&deadline));
    double difference = std::difftime(deadline_time, now) / (60 * 60 * 24);  // Convert seconds to days

    return static_cast<int>(difference);  // Return the number of days
}

// Helper function to parse a date input as "YYYY-MM-DD"
std::tm parseDate(const std::string& dateStr) {
    std::tm date = {};
    sscanf(dateStr.c_str(), "%d-%d-%d", &date.tm_year, &date.tm_mon, &date.tm_mday);

    // Adjust for struct tm format (years since 1900, months starting from 0)
    date.tm_year -= 1900;
    date.tm_mon -= 1;

    return date;
}

// Check if dependencies are met for a task
bool areDependenciesMet(const Task& task, const std::map<std::string, bool>& completedTasks) {
    for (const std::string& dep : task.dependencies) {
        if (completedTasks.at(dep) == false) {
            return false;  // Dependency not met
        }
    }
    return true;
}

// Function to allocate tasks to available members based on deadlines and dependencies
void allocateTasks(std::vector<Task>& tasks, std::vector<Member>& members) {
    std::sort(tasks.begin(), tasks.end(), [](Task& a, Task& b) {
        return daysUntilDeadline(a.deadline) < daysUntilDeadline(b.deadline);  // Sort by nearest deadline
    });

    std::map<std::string, bool> completedTasks;
    for (const auto& task : tasks) {
        completedTasks[task.name] = false;  // Initialize all tasks as incomplete
    }

    std::map<std::string, std::string> taskAssignments;

    for (auto& task : tasks) {
        if (!areDependenciesMet(task, completedTasks)) {
            std::cout << "Task " << task.name << " cannot be assigned yet due to unmet dependencies.\n";
            continue;  // Skip if dependencies aren't met
        }

        bool assigned = false;
        for (auto& member : members) {
            if (member.isAvailable) {
                taskAssignments[task.name] = member.name;
                member.isAvailable = false;  // Mark member as unavailable
                task.assigned = true;
                completedTasks[task.name] = true;  // Mark task as completed
                assigned = true;
                break;
            }
        }

        if (!assigned) {
            std::cout << "Task " << task.name << " could not be assigned (no available members).\n";
        }
    }

    // Print task assignments
    std::cout << "\nTask Assignments:" << std::endl;
    for (const auto& assignment : taskAssignments) {
        std::cout << "Task: " << assignment.first << " -> Member: " << assignment.second << std::endl;
    }
}

int main() {
    // Define tasks with deadlines (YYYY-MM-DD) and dependencies
    std::vector<Task> tasks = {
        {"Task1", parseDate("2024-10-20"), {}},  // No dependencies
        {"Task2", parseDate("2024-10-15"), {"Task1"}},  // Depends on Task1
        {"Task3", parseDate("2024-11-01"), {}},  // No dependencies
        {"Task4", parseDate("2024-10-18"), {"Task2"}}  // Depends on Task2
    };

    // Define team members and their availability
    std::vector<Member> members = {
        {"Alice", true},
        {"Bob", true},
        {"Charlie", true}
    };

    allocateTasks(tasks, members);

    return 0;
}
