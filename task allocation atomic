#include <iostream>
#include <list>
#include <string>
#include <map>
#include <ctime>
#include <algorithm>
#include <fstream>
#include <sstream>
#include <omp.h>

using namespace std;

// Task structure
struct Task {
    std::string name;
    std::tm deadline;
    std::list<std::string> dependencies;
    int duration;
    bool assigned = false;
};

// Member structure
struct Member {
    std::string name;
    bool isAvailable;
    int maxHours;
    int assignedHours;
    std::map<std::string, int> tasks;
};

// Helper function to parse a date input as "YYYY-MM-DD"
std::tm parseDate(const std::string& dateStr) {
    std::tm date = {};
    sscanf(dateStr.c_str(), "%d-%d-%d", &date.tm_year, &date.tm_mon, &date.tm_mday);
    date.tm_year -= 1900;  // Adjust for struct tm format (years since 1900)
    date.tm_mon -= 1;      // Adjust for months starting from 0
    return date;
}

// Helper function to print a date
std::string formatDate(const std::tm& date) {
    char buffer[11];
    std::strftime(buffer, sizeof(buffer), "%Y-%m-%d", &date);
    return buffer;
}

// Check if dependencies are met for a task
bool areDependenciesMet(const Task& task, const std::map<std::string, bool>& completedTasks) {
    for (const std::string& dep : task.dependencies) {
        if (!completedTasks.at(dep)) {
            return false;  // Dependency not met
        }
    }
    return true;
}

// Function to sort tasks by deadline
void sortTasksByDeadline(std::list<Task>& tasks) {
    tasks.sort([](const Task& a, const Task& b) {
        return std::difftime(mktime(const_cast<std::tm*>(&a.deadline)), mktime(const_cast<std::tm*>(&b.deadline))) < 0;
    });
}

// Function to allocate tasks to available members based on deadlines and dependencies
void allocateTasks(std::list<Task>& tasks, std::list<Member>& members) {
    std::map<std::string, bool> completedTasks;
    for (const auto& task : tasks) {
        completedTasks[task.name] = false;  // Initialize all tasks as incomplete
    }

    std::tm currentDate = parseDate("2024-10-03");  // Start date
    std::list<std::string> memberSchedules;

    // Time the sorting of tasks
    clock_t startSort = clock();
    sortTasksByDeadline(tasks);
    clock_t endSort = clock();
    double elapsedSort = double(endSort - startSort) / CLOCKS_PER_SEC;
    printf("Time to sort tasks: %.6f seconds\n", elapsedSort);

    // Time the entire task allocation process
    clock_t startAllocation = clock();

    // Parallelized task allocation
    #pragma omp parallel
    {
        // While there are tasks to allocate
        while (!tasks.empty()) {
            bool taskAssignedInRound = false;

            // Parallelized for each member to assign tasks
            #pragma omp for
            for (auto& member : members) {
                if (!member.isAvailable) continue;  // Skip unavailable members

                // Attempt to assign tasks to the current member
                for (auto it = tasks.begin(); it != tasks.end();) {
                    auto& task = *it;

                    // Check if the dependencies are met and if the member can take on the task
                    if (areDependenciesMet(task, completedTasks) && member.assignedHours < member.maxHours) {
                        if (member.assignedHours + task.duration <= member.maxHours) {
                            // Atomic operation for updating assigned hours
                            #pragma omp atomic
                            member.assignedHours += task.duration;  // Update member's assigned hours atomically

                            // Mark task as assigned and update completed tasks
                            task.assigned = true;
                            completedTasks[task.name] = true;

                            // Remove the task from the list
                            #pragma omp critical
                            {
                                it = tasks.erase(it);  // Erase task from list inside critical section
                            }
                            taskAssignedInRound = true;
                        } else {
                            ++it;
                        }
                    } else {
                        ++it;
                    }
                }
            }

            // If no task was assigned in the round, break out of the while loop
            if (!taskAssignedInRound) {
                break;
            }
        }
    }

    clock_t endAllocation = clock();
    double elapsedAllocation = double(endAllocation - startAllocation) / CLOCKS_PER_SEC;
    printf("Time for task allocation process: %.6f seconds\n", elapsedAllocation);

    // Output the assignments for the day
    std::cout << "\nMember Schedules:\n";
    for (const auto& member : members) {
        if (!member.tasks.empty()) {
            std::string schedule = formatDate(currentDate) + " - Member: " + member.name + " did ";
            schedule += std::to_string(member.tasks.size()) + " tasks with duration " + std::to_string(member.assignedHours) + "h total. Tasks: ";

            // Append the task names and durations
            for (const auto& task : member.tasks) {
                schedule += task.first + " (" + std::to_string(task.second) + "h), ";
            }

            // Remove the last comma and space
            if (!member.tasks.empty()) {
                schedule.erase(schedule.end() - 2, schedule.end());
            }

            memberSchedules.push_back(schedule);
        }
    }

    // Print the schedules after all tasks are assigned
    for (const auto& schedule : memberSchedules) {
        std::cout << schedule << "\n";
    }
}

// Function to read tasks from a file
void readTasksFromFile(const std::string& filename, std::list<Task>& tasks) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Error: Could not open file " << filename << "\n";
        return;
    }

    std::string line;
    while (std::getline(file, line)) {
        std::istringstream ss(line);
        Task task;
        std::string dependencies;

        // Read task details: name, deadline, dependencies (comma separated), duration
        std::getline(ss, task.name, ',');
        std::string dateStr;
        std::getline(ss, dateStr, ',');
        task.deadline = parseDate(dateStr);
        std::getline(ss, dependencies, ',');

        // Extracting the duration
        std::string durationStr;
        if (std::getline(ss, durationStr, ',')) {
            try {
                if (durationStr.empty()) {
                    std::cerr << "Error: Missing duration for task " << task.name << "\n";
                    continue; // Skip this task if duration is missing
                }
                task.duration = std::stoi(durationStr); // Convert duration to integer
            } catch (const std::invalid_argument& e) {
                std::cerr << "Error: Invalid duration for task " << task.name << ": " << durationStr << "\n";
                continue; // Skip this task if duration is invalid
            }
        } else {
            std::cerr << "Error: Missing duration for task " << task.name << "\n";
            continue; // Skip this task if duration is missing
        }

        // Parse dependencies
        std::istringstream depStream(dependencies);
        std::string dep;
        while (std::getline(depStream, dep, ',')) {
            task.dependencies.push_back(dep);
        }

        tasks.push_back(task);
    }

    file.close();
}

int main() {
    // Define tasks list
    std::list<Task> tasks;

    // Measure time to read tasks from file
    clock_t startFileRead = clock();
    readTasksFromFile("tasks.txt", tasks);
    clock_t endFileRead = clock();
    double elapsedFileRead = double(endFileRead - startFileRead) / CLOCKS_PER_SEC;
    printf("Time to read tasks from file: %.6f seconds\n", elapsedFileRead);

    // Define team members and their availability
    std::list<Member> members = {
        {"Alice", true, 8, 0},  // Can work up to 8 hours
        {"Bob", true, 8, 0},    // Can work up to 8 hours
        {"Sara", true, 6, 0}, 
        {"Max", true, 8, 0}, 
    };

    // Measure total execution time for task allocation
    clock_t startTotal = clock();
    
    // Allocate tasks
    allocateTasks(tasks, members);
    
    clock_t endTotal = clock();
    double elapsedTotal = double(endTotal - startTotal) / CLOCKS_PER_SEC;
    printf("Total Execution Time: %.6f seconds\n", elapsedTotal);

    return 0;
}
