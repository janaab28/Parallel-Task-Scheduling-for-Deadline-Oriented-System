# using critical in task allocation function:


#include <omp.h> // Include OpenMP header

// Function to allocate tasks to available members based on deadlines and dependencies
void allocateTasks(std::list<Task>& tasks, std::list<Member>& members) {
    std::map<std::string, bool> completedTasks;
    for (const auto& task : tasks) {
        completedTasks[task.name] = false; // Initialize all tasks as incomplete
    }

    std::tm currentDate = parseDate("2024-10-03"); // Start date
    std::list<std::string> memberSchedules;

    // Time the sorting of tasks
    clock_t startSort = clock();
    sortTasksByDeadline(tasks);
    clock_t endSort = clock();
    double elapsedSort = double(endSort - startSort) / CLOCKS_PER_SEC;
    printf("Time to sort tasks: %.6f seconds\n", elapsedSort);

    // Time the entire task allocation process
    clock_t startAllocation = clock();

    while (!tasks.empty()) {
        // Reset assigned hours for the day
        for (auto& member : members) {
            member.assignedHours = 0;
            member.tasks.clear(); // Clear tasks for the new day
        }

        bool tasksAssignedToday = false;

        #pragma omp parallel
        {
            // Parallel task assignment
            bool taskAssignedInRound = true;
            while (taskAssignedInRound) {
                taskAssignedInRound = false;

                #pragma omp for schedule(dynamic)
                for (auto it = tasks.begin(); it != tasks.end();) {
                    auto& task = *it;

                    bool taskAssigned = false;

                    #pragma omp critical
                    {
                        for (auto& member : members) {
                            if (!member.isAvailable || member.assignedHours >= member.maxHours) {
                                continue; // Skip unavailable members or those with no capacity
                            }

                            if (areDependenciesMet(task, completedTasks) &&
                                member.assignedHours + task.duration <= member.maxHours) {
                                // Assign task to member
                                member.tasks[task.name] = task.duration;
                                member.assignedHours += task.duration;
                                task.assigned = true;
                                completedTasks[task.name] = true;
                                tasks.erase(it++); // Erase task safely inside critical section
                                taskAssigned = true;
                                tasksAssignedToday = true;
                                break; // Exit member loop once task is assigned
                            }
                        }
                    }

                    if (!taskAssigned) {
                        ++it; // Move to the next task if not assigned
                    }
                }

                if (taskAssignedInRound) {
                    taskAssignedInRound = true;
                }
            }
        }

        // Output the assignments for the day
        for (const auto& member : members) {
            if (!member.tasks.empty()) {
                std::string schedule = formatDate(currentDate) + " - Member: " + member.name + " did ";
                schedule += std::to_string(member.tasks.size()) + " tasks with duration " +
                            std::to_string(member.assignedHours) + "h total. Tasks: ";

                // Append the task names and durations
                for (const auto& task : member.tasks) {
                    schedule += task.first + " (" + std::to_string(task.second) + "h), ";
                }

                // Remove the last comma and space
                if (!member.tasks.empty()) {
                    schedule.erase(schedule.end() - 2, schedule.end());
                }

                memberSchedules.push_back(schedule);
            }
        }

        currentDate.tm_mday++;
        mktime(&currentDate); // Normalize the date (handles overflow into next month/year)

        if (!tasksAssignedToday) {
            break; // No further allocation possible
        }
    }

    clock_t endAllocation = clock();
    double elapsedAllocation = double(endAllocation - startAllocation) / CLOCKS_PER_SEC;
    printf("Time for task allocation process: %.6f seconds\n", elapsedAllocation);

    std::cout << "\nMember Schedules:\n";
    for (const auto& schedule : memberSchedules) {
        std::cout << schedule << "\n";
    }
}



